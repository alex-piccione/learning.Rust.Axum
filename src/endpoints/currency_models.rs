use serde::{Deserialize, Serialize};

use crate::entities::currency as entities;
use crate::entities::currency::CurrencyKind;

#[derive(Serialize)]
pub struct Currency {
    pub id: i32,
    pub symbol: String,
    pub name: String,
    pub kind: String,
    pub is_active: bool,
    pub precision: i16,
}

impl From<entities::Currency> for Currency {
    fn from(entity: entities::Currency) -> Self {
        Currency {
            id: entity.id,
            symbol: entity.symbol,
            name: entity.name,
            kind: entity.kind.into(), // This line works because of `impl From<CurrencyKind> for String` block
            is_active: entity.is_active,
            precision: entity.precision,
        }
    }
}

pub mod list {

    /*
    pub struct Request {
        pub page: u32,
        pub pageSize: u32,
    }
     */

     /*
    pub struct Response {
        pub currencies: Vec<Currency>,
        pub totalCount: i32,
    }
     */
}


#[derive(Deserialize)]
pub struct CreateRequest {
    pub symbol: String,
    pub name: String,
    pub kind: String,
    pub is_active: bool,
    pub precision: i16,
}

impl CreateRequest {
    pub fn to_entity(self) -> Result<entities::Currency, String> {
        let kind_enum = match self.kind.as_str() {
            "Fiat" => CurrencyKind::Fiat,
            "Crypto" => CurrencyKind::Crypto,
            "Stablecoin" => CurrencyKind::Stablecoin,
            _ => return Err(format!("Unknown currency kind: {}", self.kind)),
        };

        Ok(entities::Currency {
            id: 0, // ID will be generated by the database
            symbol: self.symbol,
            name: self.name,
            kind: kind_enum,
            is_active: self.is_active,
            precision: self.precision,
        })
    }
}


#[derive(Serialize)]
pub struct CreateResponse {
    pub new_id: i32,
}
